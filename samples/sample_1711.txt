"I don't understand what it is that you want to achieve here, I guess. I'm looking at the code that you've written, it seems to be a valid expression. Your first program seems to work. And, it does indeed take less time than your second program. So, I'm wondering what it is you are trying to achieve here, with these two different approaches. It seems like you're doing exactly what you should be doing, from a coding perspective, in each case. If it takes less time to execute a valid expression than an invalid one, it's because of the way that the evaluator works. And, it will take exactly the same amount of time for each execution, since the time is due to the very expression you are evaluating. If it were more expensive to evaluate one expression than the other, then you would not get exactly the same execution time for each execution of the program, but the one that you have written seems to be producing the same execution time for each execution.\n\nLooking at the times returned by the timing subroutine, I think it's time to read your first post carefully again, because the results you are getting with the timing subroutine seem to be a bit surprising. For example, your first program is using a compiled version of your code, since you compile it with -c . But, you have your test cases written as though you were executing the code directly, without any pre-compilation. You get a total execution time of about 2 seconds, and then you call the timing subroutine, and you get the following times for the code that you have written:\n\n(load (compile 'sample)) -> 0.004119s\n\n(load (compile 'valid)) -> 0.003774s\n\n(load (compile 'invalid)) -> 0.003771s\n\n(time (load (compile 'valid))) -> 0.003794s\n\n(time (load (compile 'invalid))) -> 0.003784s\n\n(time (load (compile 'sample))) -> 0.004119s\n\nI'm not saying that this is wrong, but it's certainly not what I would have expected. You say that it takes about 2 seconds to evaluate your code without pre-compiling, and then about 0.1 seconds to execute the compiled version. But, you are timing your un-compiled code to be taking about the same amount of time as your compiled code. I'm trying to understand the sequence of events, from your first post:\n\nEvaluate the code in my head -> ~2s\n\nType the code into the file -> ~2s\n\nCompile the file -> ~0.1s\n\nI guess I would expect that pre-compiling the code would take less time than evaluating it in my head, and I guess I would also expect that the evaluation time for your compiled code would be a lot less than the evaluation time for the un-compiled code. And, if the evaluation time is pretty much the same, then I would expect the pre-compile time to be significantly less than the pre-compile time for the code that you are timing.\n\nI'm just having a difficult time understanding how this is all working, from a code perspective.\n\nI'm just hoping you will explain what you are trying to do. Why do you think that the second version is "easier to read"? Why do you think that it is "easier to debug"? Is there a reason why you need to run both versions? I don't see how the compiler could make your code any easier to debug, for example.\n\nI'm sorry if I'm not making sense. I'm still trying to figure out exactly what you are doing here, and how you are trying to accomplish it.