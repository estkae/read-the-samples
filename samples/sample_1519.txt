"One of the main features of GitLab’s Continuous Integration (CI) is its ability to test your code with a variety of tests and coveralls.\n\nThe testing procedure usually consists of a script that you can implement yourself. In this article, I will demonstrate how to automate the testing procedure of JSF application using GitLab and Junit.\n\nHere is the complete GitLab CI configuration file:\n\nimage: java:openjdk-8 stages: - test - deploy test: stage: test image: localhost:8010 stages: - check-java-dependencies - run-selenium test-selenium: stage: test script: - jdk: name: openjdk8 - junit: name: junit - clean-builds - selenium: start-server: name: selenium_server_start url: http://localhost:4444/wd/hub/ results: reports: html: - coveralls - results-xml deploy: stage: deploy image: localhost:8010 deploy: replicas: 3 script: - apt-get: name: openjdk-8-jdk update: - gitlab-ci-multi-runner update-runner --web java:openjdk-8 - mvn: name: junit - build-project: groupId: net.idcl.sample artifactId: sample-project - deploy: name: war target: /tmp/project deploy: replicas: 3\n\nTesting the JSF application\n\nFirst, we need to create a Java class to be tested. In this example, I will use a JSF library. The library will contain a simple form that will accept and validate input from the user.\n\npublic class Sample { public static void main(String[] args) { Sample test = new Sample(); test.mainForm(); } @Autowired private FacesContext context; private void mainForm() { context.addMessage("Form submitted..."); } }\n\nThe next step is to create a unit test, which can be done with the help of JUnit. Here is the corresponding unit test:\n\npublic class SampleJunit { @Rule public MockitoJUnitRule rule = new MockitoJUnitRule(); @Mock private Sample test; @Before public void init() { // @After public void end() { // } @Test public void testMainForm() { test.setMessage("Form submitted..."); expect(test.mainForm()).andReturn(null); rule.doNothing().when(test); verify(test).mainForm(); } }\n\nTo make things work, you will need to add junit to your classpath.\n\nNext, we can set up GitLab’s JUnit runner. The JUnit runner can be enabled by adding the following lines to the .gitlab-ci.yml file:\n\nbefore_script: - mvn test -Dgitlab.junit.gitlab-ci.executable.version=1.6.0\n\nHere, the version of JUnit is explicitly set in the .gitlab-ci.yml file. To get the current version, we can check it on GitLab, under Settings > CI/CD > Advanced configuration.\n\nRunning the test\n\nAfter that, we can push the code to GitLab’s master branch and run the test. When all the tests are successful, the result of the test is as follows:\n\nIf the test fails, the result looks like this:\n\nDeploying a JSF application\n\nAfter we’ve successfully tested the JSF application, the next step is to deploy the application on a server. To make it work, we need to install GitLab’s Runner on the server, which is done through the command line:\n\ncurl -L https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner.deb -o gitlab-ci-multi-runner.deb sudo dpkg -i gitlab-ci-multi-runner.deb\n\nNext, we can configure the deployment on the server. For this, we need to add a runner to the .gitlab-ci.yml file:\n\nstages: - test - deploy test: stage: test image: localhost:8010 stages: - check-java-dependencies - run-selenium test-selenium: stage: test script: - jdk: name: openjdk8 - junit: name: junit - clean-builds - selenium: start-server: name: selenium_server_start url: http://localhost:4444/wd/hub/ results: reports: html: - coveralls - results-xml deploy: stage: deploy image: localhost:8010 deploy: replicas: 3 script: - apt-get: name: openjdk-8-jdk update: - gitlab-ci-multi-runner update-runner --web java:openjdk-8 - mvn: name: junit - build-project: groupId: net.idcl.sample artifactId: sample-project - deploy: name: war target: /tmp/project deploy: replicas: 3\n\nHere, the runner is used for the test phase. After that, the runner is installed on the server, and the project is deployed.